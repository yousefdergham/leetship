import { GitHubConfig, CommitPayload } from '../types'

export interface RepositoryAccess {
  accessible: boolean
  permissions: {
    admin: boolean
    push: boolean
    pull: boolean
  } | null
  error?: string
}

export interface FileSha {
  sha: string
  path: string
}

export interface UpsertFileResult {
  contentPath: string
  commitUrl: string
}

export class GitHubClient {
  private baseURL = 'https://api.github.com'

  constructor(private config: GitHubConfig) {}

  /**
   * Helper function to make GitHub API requests with proper headers
   */
  private async ghFetch(url: string, init: RequestInit = {}): Promise<Response> {
    const headers = {
      Authorization: `token ${this.config.accessToken}`,
      Accept: 'application/vnd.github.v3+json',
      'X-GitHub-Api-Version': '2022-11-28',
      'User-Agent': 'LeetShip (+webextension)',
      ...init.headers,
    }

    return fetch(`${this.baseURL}${url}`, {
      ...init,
      headers,
    })
  }

  /**
   * Validate repository and branch access
   */
  async validateRepoAccess(owner: string, repo: string, branch: string): Promise<RepositoryAccess> {
    try {
      const response = await this.ghFetch(`/repos/${owner}/${repo}/branches/${branch}`)

      if (!response.ok) {
        const errorText = await response.text()
        return {
          accessible: false,
          permissions: null,
          error: `Cannot access ${owner}/${repo}@${branch}: ${errorText}`,
        }
      }

      // Also check repository permissions
      const repoResponse = await this.ghFetch(`/repos/${owner}/${repo}`)

      if (!repoResponse.ok) {
        const errorText = await repoResponse.text()
        return {
          accessible: false,
          permissions: null,
          error: `Cannot access repository ${owner}/${repo}: ${errorText}`,
        }
      }

      const repoData = await repoResponse.json()

      return {
        accessible: true,
        permissions: repoData.permissions,
      }
    } catch (error) {
      return {
        accessible: false,
        permissions: null,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * Get file SHA if it exists
   */
  async getFileSha(
    owner: string,
    repo: string,
    path: string,
    branch: string
  ): Promise<string | undefined> {
    try {
      const response = await this.ghFetch(
        `/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${branch}`
      )

      if (response.status === 404) {
        return undefined
      }

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`Failed to get file info (${response.status}): ${errorText}`)
      }

      const fileData = await response.json()
      return fileData.sha
    } catch (error) {
      if (error instanceof Error && error.message.includes('404')) {
        return undefined
      }
      throw error
    }
  }

  /**
   * Create or update a file
   */
  async upsertFile(owner: string, repo: string, payload: CommitPayload): Promise<UpsertFileResult> {
    const { path, content, message, branch, sha } = payload

    // Base64 encode the content
    const encodedContent = btoa(unescape(encodeURIComponent(content)))

    const body: any = {
      message,
      content: encodedContent,
      branch: branch || this.config.branch,
    }

    // Include SHA if updating existing file
    if (sha) {
      body.sha = sha
    }

    const response = await this.ghFetch(
      `/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`,
      {
        method: 'PUT',
        body: JSON.stringify(body),
      }
    )

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Failed to upsert file (${response.status}): ${errorText}`)
    }

    const result = await response.json()

    return {
      contentPath: result.content.path,
      commitUrl: result.commit.html_url,
    }
  }

  /**
   * Test commit by creating/updating a README.md file
   */
  async testCommit(owner: string, repo: string, branch: string): Promise<UpsertFileResult> {
    const testContent = `# Test Commit

This is a test commit from LeetShip extension.

- **Timestamp**: ${new Date().toISOString()}
- **Extension**: LeetShip v1.0.2
- **Purpose**: Testing GitHub API integration

If you see this file, the GitHub integration is working correctly! ðŸŽ‰

---

*This file was automatically generated by LeetShip extension.*`

    const testMessage = 'test: Verify GitHub API integration'

    // Check if README.md already exists
    const existingSha = await this.getFileSha(owner, repo, 'README.md', branch)

    return await this.upsertFile(owner, repo, {
      path: 'README.md',
      content: testContent,
      message: testMessage,
      branch,
      sha: existingSha,
    })
  }
}
